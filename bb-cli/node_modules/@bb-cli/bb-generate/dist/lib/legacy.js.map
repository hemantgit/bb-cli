{"version":3,"sources":["../../src/lib/legacy.js"],"names":["isFunction","a","isLegacyGenerator","generator","prefixSuffixRegex","getBaseName","name","replace","templateTransforms","data","transforms","camelCase","value","capitalize","baseName","suffixless","base","baseCamelCase","baseCapitalize","dataTransform","namespaces","forEach","ns","preTransformHook","warn","legacyConfig","hooks","preTransform","template","settings","rename","match","defaultQuestions","type","message","validate","isRequired","filter","deburr","kebabCase","str","split","mergeQuestions","generatorQuestions","questions","hasAdditionalQuestions","additionalQuestions","convertLegacyGenerator","legacyGenerator","generatorFactory"],"mappings":"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","file":"legacy.js","sourcesContent":["\nimport { pipe, map, trim, unionWith, eqProps, merge } from 'ramda';\nimport { log } from '@bb-cli/base';\nimport { filter, validate } from './generator-api';\n\nconst isFunction = (a) => (typeof a === 'function');\n\nconst isLegacyGenerator = (generator) => !isFunction(generator);\n\n// Extract part of the name without prefixes and suffixes.\nconst prefixSuffixRegex = /^(?:ui-bb|widget-bb|model-bb|widget)-(.*?)-?(?:ng|ext)?$/;\nconst getBaseName = (name) => name.replace(prefixSuffixRegex, '$1');\n\nconst templateTransforms = (data) => {\n  const transforms = map(value => ({\n    camelCase: filter.camelCase(value),\n    capitalize: filter.capitalize(value),\n  }), data);\n\n  if (data.name && transforms.name) {\n    const baseName = getBaseName(data.name);\n    transforms.name = merge(transforms.name, {\n      suffixless: data.name.replace(/-ng(?:-ext)?$/, ''),\n      base: baseName,\n      baseCamelCase: filter.camelCase(baseName),\n      baseCapitalize: filter.capitalize(baseName),\n    });\n  }\n\n  return transforms;\n};\n\n\nconst dataTransform = (data) => {\n  // mutate data\n  data.transforms = templateTransforms(data); // eslint-disable-line no-param-reassign\n\n  // Assign to namespaces.\n  const namespaces = ['widget', 'container', 'module', 'component'];\n  namespaces.forEach(ns => {\n    data[ns] = data || {}; // eslint-disable-line no-param-reassign\n  });\n\n  return data;\n};\n\nconst preTransformHook = (data) => {\n  log.warn('LEGACY', 'Using a legacy version of this generator. Upgrade it to the latest.');\n  return dataTransform(data);\n};\n\nconst legacyConfig = {\n  hooks: {\n    preTransform: preTransformHook,\n  },\n  template: {\n    settings: null,\n    rename: {\n      match: /__(.+?)__/g,\n      replace: (data, match) => data.transforms.name[match] || data[match],\n    },\n  },\n};\n\nconst defaultQuestions = (generator) => {\n  if (generator.defaultQuestions && isFunction(generator.defaultQuestions)) {\n    return generator.defaultQuestions();\n  }\n\n  // todo: use presets\n  return [\n    {\n      type: 'input',\n      name: 'name',\n      message: 'Name',\n      validate: value => validate.isRequired(value, 'Name is required'),\n      filter: pipe(filter.deburr, filter.kebabCase),\n    },\n    {\n      type: 'input',\n      name: 'title',\n      message: 'Title',\n      validate: value => validate.isRequired(value, 'Title is required'),\n      filter: trim,\n    },\n    {\n      type: 'input',\n      name: 'description',\n      message: 'Description',\n      validate: value => validate.isRequired(value, 'Description is required'),\n      filter: trim,\n    },\n    {\n      name: 'tags',\n      message: 'Tags',\n      filter: (str) => str.split(/\\s*,\\s*/),\n    },\n  ];\n};\n\nconst mergeQuestions = unionWith(eqProps('name'));\n\nconst generatorQuestions = (generator) => {\n  let questions = defaultQuestions(generator);\n  const hasAdditionalQuestions = generator.additionalQuestions &&\n    isFunction(generator.additionalQuestions);\n\n  if (hasAdditionalQuestions) {\n    questions = mergeQuestions(questions, generator.additionalQuestions());\n  }\n\n  return questions;\n};\n\nconst convertLegacyGenerator = (legacyGenerator) => (generatorFactory) => {\n  // Prompts\n  const questions = generatorQuestions(legacyGenerator);\n  return generatorFactory(questions, legacyConfig);\n};\n\nexport {\n  isLegacyGenerator,\n  convertLegacyGenerator,\n};\n"]}