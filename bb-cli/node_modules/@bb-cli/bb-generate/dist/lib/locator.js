'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _glob = require('glob');

var _ramda = require('ramda');

var R = _interopRequireWildcard(_ramda);

var _base = require('@bb-cli/base');

var _utils = require('./utils');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @todo
 * - handle no results output
 * - optimize map calls to use transducer
 * - cache result in $HOME
 * - make preparePackageMeta a bit more clear
 * - use Future instead of Promises
 * - sort by scope DESC
 * - use Empty http://ramdajs.com/docs/#empty for empty results
 *
 */
var statFileExistsFilter = function statFileExistsFilter(code) {
  return code !== 'ENOENT';
};

var fileExistsSync = R.pipe(_fs2.default.statSync, statFileExistsFilter);

var parseFileSync = R.pipe(R.flip(_fs2.default.readFileSync)('utf-8'), JSON.parse);

var execShellComand = function execShellComand(cmd) {
  var result = _base.sh.exec(cmd, { silent: true });
  if (result.code !== 0) {
    throw (0, _base.error)({
      type: 'E_EXEC',
      code: result.code,
      message: result.stderr.trim()
    });
  }
  return result.stdout.trim();
};

var GLOB_PATTERN = '?(bb-generator-*|generator-*)';

var getLocalNpmRootNodeModules = function getLocalNpmRootNodeModules() {
  var cmd = 'npm root --loglevel error';
  return execShellComand(cmd);
};
var getGlobalNpmRootNodeModules = function getGlobalNpmRootNodeModules() {
  var cmd = 'npm root --global --loglevel error';
  return execShellComand(cmd);
};

var createGlobPattern = function createGlobPattern(scope) {
  var scopeGlob = scope || '@*';
  var globs = [scopeGlob + '/' + GLOB_PATTERN + '/package.json', './' + GLOB_PATTERN + '/package.json'];
  var pattern = '{' + globs.join(',') + '}';
  if (scope) {
    globs.pop();
    // unwrap { }
    pattern = '' + globs.join(',');
  }
  _base.log.verbose('GLOB', pattern);
  return pattern;
};

var search = function search(pattern, npmRoot) {
  var results = [];

  var foundMatches = function foundMatches(match) {
    results.push(_path2.default.resolve(npmRoot, match));
    _base.log.verbose('PACKAGE', _path2.default.resolve(npmRoot, match));
  };

  return new Promise(function (resolve, reject) {
    var globSearch = new _glob.Glob(pattern, { cwd: npmRoot });
    globSearch.on('error', reject);
    globSearch.on('match', foundMatches);
    globSearch.on('end', function () {
      return resolve(results);
    });
  });
};

var searchLocal = function searchLocal(pattern) {
  return search(pattern, getLocalNpmRootNodeModules());
};
var searchGlobal = function searchGlobal(pattern) {
  return search(pattern, getGlobalNpmRootNodeModules());
};

/**
 * Searches generators in global and local node_modules
 * @private
 * @func
 * @since v2.0.0
 * @category List
 * @sig String -> Promise Array
 * @param {String} GLob Pattern
 * @return {Promise} List of results
 */
var searchNodeModules = function searchNodeModules(patern) {
  return Promise.all([searchGlobal(patern), searchLocal(patern)]).then(R.flatten);
};

/**
 * Creates a Generator Object from the given package.json file
 * @todo Split into smaller composable functions
 * @private
 * :: String -> Array
 */

var createGeneratorObject = function createGeneratorObject(packageJsonFile) {
  var generatorName = function generatorName(str) {
    return str.replace(/^([^\/]+\/)?(bb-)?generator-/, '');
  };

  var getScopeFromName = function getScopeFromName(str) {
    var splitPackageName = str.split('/');
    return splitPackageName.length > 1 ? splitPackageName[0] : '';
  };
  var pickPackageProperties = R.pick(['name', 'main', 'keywords', // @todo filter by tags
  'description', 'version', 'directories']);

  var preparePackageMeta = function preparePackageMeta(packageJson) {
    var dirName = _path2.default.dirname(packageJsonFile);
    var templatePaths = function templatePaths() {
      var main = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'index.js';
      var directories = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return R.map(function (templatePath) {
        return _path2.default.resolve(dirName, _path2.default.normalize(templatePath, main));
      }, R.merge({ default: main }, directories));
    };

    return R.merge(packageJson, {
      displayName: generatorName(packageJson.name),
      templates: templatePaths(packageJson.main, packageJson.directories),
      scope: getScopeFromName(packageJson.name),
      dirName: dirName
    });
  };

  return R.pipe(parseFileSync, pickPackageProperties, preparePackageMeta, R.omit(['main', 'directories']))(packageJsonFile);
};

/**
 * Tries to see if the template paths exists
 * @private
 * :: Object -> Object
 */
var checkTemplatePaths = function checkTemplatePaths(obj) {
  try {
    return R.map(fileExistsSync, obj.templates);
  } catch (err) {
    _base.log.warn(err);
    _base.log.warn('Unable to include generator ' + obj.dirName);
    return false;
  }
};

/**
 * Get available generators
 * @module @bb-cli/bb-generate.list
 * @type {Object}
 * @since v2.0.0
 * @public
 * @returns {Promise.<GeneratorsFoundCollection>} Array of objects
 * @example
 *
 * ```javascript
 * import { list } from '@bb-cli/bb-generate';
 *
 * const options {
 *  scope: '@backbase',
 *  format: 'json',
 * };
 *
 * list(options)
 *   .then(handleSearchResults, handleErrors);
 * ```
 */

exports.default = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var pattern = createGlobPattern(options.scope);
  return (0, _utils.pipeline)(searchNodeModules, R.map(createGeneratorObject), R.filter(checkTemplatePaths))(pattern);
};
//# sourceMappingURL=locator.js.map